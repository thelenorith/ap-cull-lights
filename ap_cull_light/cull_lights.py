"""
Generated By: Cursor (Claude Sonnet 4.5)

Main module for culling astrophotography light frames based on FITS header rules.
"""

import argparse
import logging
import os
import re
from pathlib import Path
from typing import Any, Dict, List, Optional

import ap_common
from ap_common.logging_config import setup_logging
from . import config

# Configure logging
logger = logging.getLogger(__name__)


def reject_image(
    filepath: str,
    reject_dir: str,
    source_dir: str,
    dryrun: bool = False,
    debug: bool = False,
) -> None:
    """
    Move an image to the reject directory, preserving relative directory structure.

    Args:
        filepath: Full path to the file to reject
        reject_dir: Root directory for rejected images
        source_dir: Source directory (to compute relative path)
        dryrun: If True, don't actually move the file
        debug: If True, print debug information
    """
    filepath_obj = Path(filepath)
    source_path = Path(source_dir).resolve()
    filepath_resolved = filepath_obj.resolve()

    # Compute relative path from source directory
    try:
        relative_path = filepath_resolved.relative_to(source_path)
    except ValueError:
        # File is not under source_dir, use just the filename
        relative_path = Path(filepath_obj.name)

    # Create destination path
    dest_path = Path(reject_dir) / relative_path
    dest_dir = dest_path.parent

    # Verify destination is under reject_dir (safety check)
    reject_path = Path(reject_dir).resolve()
    dest_resolved = dest_path.resolve()
    # Use proper path comparison - check if dest is relative to reject_path
    try:
        dest_resolved.relative_to(reject_path)
    except ValueError:
        # dest_resolved is not under reject_path - security violation
        raise ValueError(
            f"ERROR: Attempting to move file to invalid location outside reject_dir!\n"
            f"  filepath: {filepath}\n"
            f"  reject_dir: {reject_dir}\n"
            f"  dest_path: {dest_path}\n"
            f"  dest_resolved: {dest_resolved}"
        )

    if dryrun:
        if debug:
            logger.debug(f"  [DRYRUN] Would move: {filepath} -> {dest_path}")
        print(f"REJECTED: {relative_path}")
    else:
        try:
            # Create destination directory
            dest_dir.mkdir(parents=True, exist_ok=True)

            # Move the file
            ap_common.move_file(
                from_file=str(filepath), to_file=str(dest_path), debug=debug
            )
            print(f"REJECTED: {relative_path}")
        except OSError as e:
            error_msg = f"Failed to move file {relative_path}: {e}"
            logger.error(error_msg)
            print(f"ERROR: {error_msg}")
            raise
        except Exception as e:
            error_msg = f"Unexpected error moving file {relative_path}: {e}"
            logger.error(error_msg, exc_info=debug)
            print(f"ERROR: {error_msg}")
            raise


def cull_lights(
    source_dir: str,
    reject_dir: str,
    max_hfr: Optional[float] = None,
    max_rms: Optional[float] = None,
    auto_yes_percent: float = -1,
    skip_pattern: Optional[re.Pattern] = None,
    debug: bool = False,
    dryrun: bool = False,
    quiet: bool = False,
) -> None:
    """
    Cull light frames based on HFR and RMS thresholds.

    Args:
        source_dir: Source directory containing light frames
        reject_dir: Directory to move rejected images to
        max_hfr: Maximum HFR value (reject if HFR > max_hfr)
        max_rms: Maximum RMS in arcsec (reject if RMS > max_rms)
        auto_yes_percent: Auto-accept if rejection percentage is below this (0.0-100.0, default: -1 = prompt always)
        skip_pattern: Compiled regex pattern - files matching the pattern will be skipped
        debug: Enable debug output
        dryrun: Perform dry run without actually moving files
        quiet: Suppress progress output
    """
    # Get metadata for all FITS files
    required_properties: list[str] = (
        []
    )  # No specific requirements, rules engine handles missing headers
    data = ap_common.get_filtered_metadata(
        dirs=[source_dir],
        patterns=[config.INPUT_PATTERN_ALL],
        recursive=True,
        required_properties=required_properties,
        filters={"type": "LIGHT"},
        debug=debug,
        profileFromPath=True,
        printStatus=not quiet,
    )

    # Group files by directory (for batch rejection confirmation)
    data_groups: Dict[str, List[Dict[str, Any]]] = {}

    for filename, metadata in data.items():
        # Skip files matching skip pattern
        if skip_pattern and skip_pattern.search(filename):
            if debug:
                logger.debug(
                    f"Skipping {filename} (matches pattern: {skip_pattern.pattern})"
                )
            continue

        # Get directory path (use resolved path for consistent grouping)
        directory = str(Path(filename).resolve().parent)

        if directory not in data_groups:
            data_groups[directory] = []
        data_groups[directory].append(metadata)

    if debug:
        logger.debug(f"Found {len(data_groups)} directory groups")
        for dir_path, files in data_groups.items():
            logger.debug(f"  {dir_path}: {len(files)} files")

    # Process each directory group
    overall_count_reject = 0
    overall_count_total = 0

    for directory, file_metadata_list in data_groups.items():
        count_reject = 0
        count_total = len(file_metadata_list)
        overall_count_total += count_total

        rejected_files = []

        # Evaluate thresholds for each file
        for metadata in file_metadata_list:
            reasons = []
            should_reject = False

            # Check HFR threshold
            if max_hfr is not None:
                hfr_value = metadata.get("hfr")
                if hfr_value is not None:
                    try:
                        hfr_float = float(hfr_value)
                        if hfr_float > max_hfr:
                            should_reject = True
                            reasons.append(f"HFR={hfr_float} > {max_hfr}")
                    except (ValueError, TypeError):
                        if debug:
                            filename_for_log = metadata.get("filename", "unknown")
                            logger.warning(
                                f"Skipping HFR check for {filename_for_log}: "
                                f"non-numeric HFR value '{hfr_value}'"
                            )

            # Check RMS threshold
            if max_rms is not None:
                rms_value = metadata.get("rmsac")
                if rms_value is not None:
                    try:
                        rms_float = float(rms_value)
                        if rms_float > max_rms:
                            should_reject = True
                            reasons.append(f"RMS={rms_float} > {max_rms} arcsec")
                    except (ValueError, TypeError):
                        if debug:
                            filename_for_log = metadata.get("filename", "unknown")
                            logger.warning(
                                f"Skipping RMS check for {filename_for_log}: "
                                f"non-numeric RMS value '{rms_value}'"
                            )

            if should_reject:
                count_reject += 1
                filename = metadata.get("filename")
                if filename is None:
                    logger.warning(
                        "Metadata missing 'filename' field, skipping rejection"
                    )
                    continue
                rejected_files.append((filename, reasons))

        # Prompt for confirmation if there are rejections
        if count_reject > 0:
            print("=" * 60)
            dir_short = directory.replace(source_dir, "").lstrip(os.sep)
            print(f"Reject for '{dir_short}':")
            for filename, reasons in rejected_files:
                print(f"  {Path(filename).name}:")
                for reason in reasons:
                    print(f"    - {reason}")

            rejection_percent = 100 * count_reject / count_total
            question = (
                f"OK to reject {count_reject}/{count_total} "
                f"({rejection_percent:.1f}%)? (y/N)"
            )

            if auto_yes_percent >= 0 and rejection_percent < auto_yes_percent:
                # Auto-accept if below threshold
                print(f"{question} y (automatic, < {auto_yes_percent}%)")
                answer = "y"
            elif dryrun:
                # Auto-accept in dryrun mode
                print(f"{question} y (dryrun)")
                answer = "y"
            else:
                answer = input(question).strip().lower()

            if answer == "y":
                overall_count_reject += count_reject
                for filename, reasons in rejected_files:
                    reject_image(
                        filepath=filename,
                        reject_dir=reject_dir,
                        source_dir=source_dir,
                        dryrun=dryrun,
                        debug=debug,
                    )
            else:
                print("Skipping rejection for this directory group")
            print("=" * 60)

    # Print summary
    if overall_count_total > 0:
        overall_percent = 100 * overall_count_reject / overall_count_total
        print(
            f"\nTotal Rejected: {overall_count_reject} of {overall_count_total} "
            f"({overall_percent:.1f}%)"
        )
    print(f"Done with {source_dir}")


def main() -> None:
    """Main entry point for the command-line interface."""
    parser = argparse.ArgumentParser(
        description="Cull astrophotography light frames based on FITS header rules"
    )
    parser.add_argument(
        "source_dir",
        type=str,
        help="Source directory containing light frames to cull",
    )
    parser.add_argument(
        "reject_dir",
        type=str,
        help="Directory to move rejected images to (relative structure preserved)",
    )

    parser.add_argument(
        "--max-hfr",
        type=float,
        default=None,
        help="Maximum HFR value (reject if HFR > max_hfr)",
    )
    parser.add_argument(
        "--max-rms",
        type=float,
        default=None,
        help="Maximum RMS in arcsec (reject if RMS > max_rms)",
    )
    parser.add_argument(
        "--auto-accept-percent",
        type=float,
        default=-1,
        help="Auto-accept if rejection percentage is below this (0.0-100.0, default: -1 = always prompt)",
    )
    parser.add_argument(
        "--skip-regex",
        type=str,
        default=None,
        help="Regex pattern to skip files/directories (e.g., 'accept' or 'accept|processed' to skip multiple patterns)",
    )

    parser.add_argument("--debug", action="store_true", help="Enable debug output")
    parser.add_argument(
        "--dryrun", action="store_true", help="Perform dry run without moving files"
    )
    parser.add_argument(
        "-q", "--quiet", action="store_true", help="Suppress progress output"
    )

    args = parser.parse_args()

    # Configure logging
    setup_logging(name="ap_cull_light", debug=args.debug, quiet=args.quiet)

    # Validate at least one threshold is specified
    if args.max_hfr is None and args.max_rms is None:
        parser.error("Must specify at least one of --max-hfr or --max-rms")

    # Validate auto-accept-percent range
    if args.auto_accept_percent != -1:
        if args.auto_accept_percent < 0.0 or args.auto_accept_percent > 100.0:
            parser.error(
                f"--auto-accept-percent must be between 0.0 and 100.0 (got {args.auto_accept_percent})"
            )

    # Compile skip pattern
    skip_pattern = None
    if args.skip_regex:
        try:
            skip_pattern = re.compile(args.skip_regex)
        except re.error as e:
            parser.error(f"Invalid regex pattern in --skip-regex: {e}")

    # Validate directories
    source_path = Path(args.source_dir)
    reject_path = Path(args.reject_dir)

    if not source_path.exists():
        parser.error(f"Source directory does not exist: {args.source_dir}")

    if not source_path.is_dir():
        parser.error(f"Source path is not a directory: {args.source_dir}")

    # Check if source and reject directories are the same
    if source_path.resolve() == reject_path.resolve():
        parser.error(
            f"Source and reject directories cannot be the same: {args.source_dir}"
        )

    # Run culling
    cull_lights(
        source_dir=args.source_dir,
        reject_dir=args.reject_dir,
        max_hfr=args.max_hfr,
        max_rms=args.max_rms,
        auto_yes_percent=args.auto_accept_percent,
        skip_pattern=skip_pattern,
        debug=args.debug,
        dryrun=args.dryrun,
        quiet=args.quiet,
    )


if __name__ == "__main__":
    main()
